
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>Demystifying Face Recognition IV: Face-Alignment</title>
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" type="text/css" href="../../../../assets/css/styles.min.css?v=dbb78caff2">
    <link rel="stylesheet" type="text/css" href="../../../../assets/css/vendors.min.css?v=dbb78caff2">

    

    

    <link href="https://fonts.googleapis.com/css?family=Montserrat:400,400i,500,700,700i" rel="stylesheet">

    <meta name="description" content="How does Face Alignment effect the accuracy of Face Recognition algorithm?">
    <link rel="shortcut icon" href="../../../../favicon.png" type="image/png">
    <link rel="canonical" href="index.html">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <link rel="amphtml" href="amp/index.html">
    
    <meta property="og:site_name" content="BLCV - Bartosz Ludwiczuk Computer Vision">
    <meta property="og:type" content="article">
    <meta property="og:title" content="Demystifying Face Recognition IV: Face-Alignment">
    <meta property="og:description" content="How does Face Alignment effect the accuracy of Face Recognition algorithm?">
    <meta property="og:url" content="http://localhost:2368/2017/12/28/demystifying-face-recognition-iii-face-preprocessing/">
    <meta property="og:image" content="http://localhost:2368/content/images/2017/11/deepface_logo-1.png">
    <meta property="article:published_time" content="2017-12-28T09:55:00.000Z">
    <meta property="article:modified_time" content="2018-01-02T13:29:06.000Z">
    <meta property="article:tag" content="face-recogition">
    
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Demystifying Face Recognition IV: Face-Alignment">
    <meta name="twitter:description" content="How does Face Alignment effect the accuracy of Face Recognition algorithm?">
    <meta name="twitter:url" content="http://localhost:2368/2017/12/28/demystifying-face-recognition-iii-face-preprocessing/">
    <meta name="twitter:image" content="http://localhost:2368/content/images/2017/11/deepface_logo-1.png">
    <meta name="twitter:label1" content="Written by">
    <meta name="twitter:data1" content="Bartosz Ludwiczuk">
    <meta name="twitter:label2" content="Filed under">
    <meta name="twitter:data2" content="face-recogition">
    <meta property="og:image:width" content="300">
    <meta property="og:image:height" content="180">
    
    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name": "BLCV - Bartosz Ludwiczuk Computer Vision",
        "logo": "http://localhost:2368/content/images/2017/11/logo.png"
    },
    "author": {
        "@type": "Person",
        "name": "Bartosz Ludwiczuk",
        "url": "http://localhost:2368/author/bartosz/",
        "sameAs": []
    },
    "headline": "Demystifying Face Recognition IV: Face-Alignment",
    "url": "http://localhost:2368/2017/12/28/demystifying-face-recognition-iii-face-preprocessing/",
    "datePublished": "2017-12-28T09:55:00.000Z",
    "dateModified": "2018-01-02T13:29:06.000Z",
    "image": {
        "@type": "ImageObject",
        "url": "http://localhost:2368/content/images/2017/11/deepface_logo-1.png",
        "width": 300,
        "height": 180
    },
    "keywords": "face-recogition",
    "description": "How does Face Alignment effect the accuracy of Face Recognition algorithm?",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "http://localhost:2368/"
    }
}
    </script>

    <script type="text/javascript" src="../../../../public/ghost-sdk.js?v=dbb78caff2"></script>
<script type="text/javascript">
ghost.init({
	clientId: "ghost-frontend",
	clientSecret: "5e332671e77e"
});
</script>
    <meta name="generator" content="Ghost 1.15">
    <link rel="alternate" type="application/rss+xml" title="BLCV - Bartosz Ludwiczuk Computer Vision" href="../../../../rss/index.html">
</head>
<body class="post-template tag-face-recogition nav-closed">

    <div class="off-canvas position-right" id="offCanvas" data-off-canvas>
    <!-- Close button -->
    <button class="close-button" aria-label="Close menu" type="button" data-close>
        <span aria-hidden="true"><i class="fa fa-times close-off-canvas" aria-hidden="true"></i></span>
    </button>

    <div class="off-canvas-ct">

        <div class="off-canvas-widget">
            <h4>Navigation</h4>
            <nav class="off-canvas-navigation">
                <ul class="menu vertical">
                        <li class="nav-item nav-home" role="presentation">
        <a class="nav-link" href="../../../../">Home</a>
    </li>
    <li class="nav-item nav-face-recognition" role="presentation">
        <a class="nav-link" href="../../../../tag/face-recogition/">Face Recognition</a>
    </li>
    <li class="nav-item nav-about" role="presentation">
        <a class="nav-link" href="../../../../about-blcv/">About</a>
    </li>

                </ul>
            </nav>
        </div>

        <div class="off-canvas-widget">
            <div class="category-widget-section side-widget">
                <ul class="vertical menu" data-accordion-menu>
                    <li>
                        <a href="index.html#" class="tags-widget"><h4>Tag list</h4></a>
                        <ul class="menu vertical nested" id="tag-list-off"></ul>
                    </li>
                </ul>
            </div>
        </div>

            <div class="off-canvas-widget">
                <div class="off-subscribe-ct">
                    <h4><i class="fa fa-rss-square" aria-hidden="true"></i> Subscribe</h4>
                    <p>Get the latest posts delivered right to your inbox.</p>
                    <form method="post" action="http://localhost:2368/subscribe/" class="subscribe-form">
    <input class="confirm" type="hidden" name="confirm"><input class="location" type="hidden" name="location"><input class="referrer" type="hidden" name="referrer">

    <div class="">
        <input class="subscribe-email" type="email" name="email" placeholder="Your email address">
        <button class="button expanded subscribe-btn" type="submit">Subscribe</button>
    </div>
    <script type="text/javascript">(function(g,h,o,s,t){h[o]('.location')[s]=h[o]('.location')[s] || g.location.href;h[o]('.referrer')[s]=h[o]('.referrer')[s] || h.referrer;})(window,document,'querySelector','value');</script>
</form>


                    <p>or subscribe <a href="http://cloud.feedly.com/#subscription/feed/blcv.pl/static//rss/"> via RSS
                    </a> with Feedly!</p>
                </div>
            </div>
    </div>
</div>
    <div class="off-canvas-content" data-off-canvas-content>
        <header id="header">
    <div class="primary-header">
        <div class="row">
            <div class="columns">
                <a id="blog-logo" href="../../../../">
                        <img src="../../../../content/images/2017/11/logo.png" alt="BLCV - Bartosz Ludwiczuk Computer Vision" height="100">
                </a>
                <ul class="no-bullet social-media clearfix">
                    <li class="nd-social-facebook">
                        <a target="_blank" href="https://www.facebook.com/bartosz.ludwiczuk"><i class="fa fa-facebook fa-lg"></i></a>
                    </li>
                    <li class="nd-social-github">
                        <a target="_blank" href="https://github.com/melgor"><i class="fa fa-github fa-lg"></i></a>
                    </li>
                    <li class="nd-social-linkedin">
                        <a target="_blank" href="https://www.linkedin.com/in/bartosz-ludwiczuk-a677a760/?trk=nav_responsive_tab_profile"><i class="fa fa-linkedin fa-lg"></i></a>
                    </li>
                    <li class="nd-social-quora">
                        <a target="_blank" href="https://www.quora.com/profile/Bartosz-Ludwiczuk"><i class="fa fa-quora fa-lg"></i></a>
                    </li>
                    
                    <li class="nd-social-kaggle">
                        <a target="_blank" href="https://www.kaggle.com/melgor"><i class="fa fa-kaggle fa-lg"></i></a>
                    </li>
                </ul>
                <div class="header-search">
                    <form method="get" class="search-form form-inline" action="index.html#">
                        <div class="input-group">
                            <input id="search-field" type="search" class="search-field input-group-field" placeholder="Search" value="" name="s" title="Search for:">
                            <div class="input-group-button">
                                <button class="button transparent search-submit-icon">
                                    <i class="fa fa-search"></i>
                                </button>
                            </div>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>
</header>
        <div class="main-container" id="main-container">
            <div class="navigation-container clearfix">
    <div class="row">
        <div class="columns">
            <nav class="header-navigation show-for-medium">
                <ul class="menu align-center header-nav">
                        <li class="nav-item nav-home" role="presentation">
        <a class="nav-link" href="../../../../">Home</a>
    </li>
    <li class="nav-item nav-face-recognition" role="presentation">
        <a class="nav-link" href="../../../../tag/face-recogition/">Face Recognition</a>
    </li>
    <li class="nav-item nav-about" role="presentation">
        <a class="nav-link" href="../../../../about-blcv/">About</a>
    </li>

                </ul>
            </nav>
            <div class="top-bar-container" data-sticky-container>
                <div class="show-off-canvas show-for-small-only sticky" data-sticky data-options="anchor: main-container; marginTop: 0; stickyOn: small;">
                    <a data-toggle="offCanvas">Menu <i class="fa fa-bars" aria-hidden="true"></i></a>
                </div>
            </div>
        </div>
    </div>
</div>
            <div class="container">
                

    <div class="row medium-unstack">
        <main id="content" class="content medium-8 large-9 columns" role="main">
            <article class="post tag-face-recogition featured">

                <header class="post-header">
                        <figure class="image-feature"><img src="../../../../content/images/2017/11/deepface_logo-1.png"></figure>

                    <div class="post-heading">
                        <h1 class="post-title">Demystifying Face Recognition IV: Face-Alignment</h1>
                        <section class="post-meta">
                            <time class="post-date" datetime="2017-12-28">28 December 2017</time>  on <a href="../../../../tag/face-recogition/">face-recogition</a>
                        </section>
                    </div>
                </header>

                <section class="post-content">
                    <div class="kg-card-markdown"><p>One of the crucial steps before learning any Machine Learning model is data preprocessing. Most of the time we just center the data and set variance to 1 (as this make the optimalization process easier). In case of Face-Recognition, we need one-more step: Face-Alignment. What is this all about? In brief, we want to facilitate the task for out model by making the position of face constant (most of the time it means that eyes, nose and mouth are roughly at same position for every image). This is a pretty common step for all known Face-Recognition algorithm. Commonly to other posts, we will ask the beginning question:<br>
<strong>Which preprocessing method for Face-Recognition is best?</strong></p>
<p>Reading this post you will find:</p>
<ol>
<li><strong>Which Face-Alignment method is best? Should we even care about it?</strong></li>
<li><strong>How many pad add around the face before feeding to image?</strong></li>
<li><strong>Which Image transform should we use?</strong></li>
<li><strong>Does quality of Facial Landmark really care?</strong></li>
<li><strong>Does number and position of reference face landmark influence the accuracy?</strong></li>
<li><strong>It is possible to learn a model for Face-Alignment?</strong></li>
</ol>
<h2 id="facealignmentmethod">Face-Alignment method</h2>
<p>First of all, let's clarify what we need for preprocessing (most of the time):</p>
<ol>
<li>Detected face in image</li>
<li>Face landmarks</li>
<li>Reference landmarks points/pose of face</li>
<li>Chosen type of transformation (ex. Similarity, Affine)</li>
</ol>
<p>Let's assume that we have image with detected face using any provided algorithm (it does not influence the final accuracy of model, it may just make dataset bigger/smaller depending on number of detected faces in image, we use <a href="https://arxiv.org/abs/1604.02878">MTCNN</a>). Then, we must decide if we want to make use of 2D alignment (most popular one) or 3D.</p>
<h3 id="2dalignment">2D Alignment</h3>
<p>At first, we will go step-by-step in 2D case. Firstly we need a face landmarks. There are many available algorithm for that task, which may return different number of such points, depending on training data annotations (there are even competiton for this task: <a href="https://pdfs.semanticscholar.org/657a/58a220b1e69d14ef7a88be859d2f8d75e6a1.pdf">Menpo Benchmark</a>). The most popular numbers are <code>68</code> or <code>5</code>. Why we may want to choose one set of points vs another? I all just depend on our reference points, which are the points of our base face position (so position of eyes,mouth etc.). We will try to make landmarks of each face as close to them as possible. How we can obtain/calculate such reference points? It is good question. We found a three ways of obtaining them:</p>
<ol>
<li>taking already known points, ex. from <a href="https://github.com/wy1iu/sphereface/blob/master/preprocess/code/face_align_demo.m#L22">SphereFace</a> paper</li>
<li>find one base image with frontal face and take points from it</li>
<li>calculate mean position of each point</li>
</ol>
<p>Having reference points, next step is choosing the padding of of face, where we mean that there can be a tight or loosely crop of face (ex. containing hair, ears). Just look at example images and see that having the same reference point and different value of padding can result in different image. Also, you could have different value of padding in height and width direction (as most of faces are oval)</p>
<p align="center">
<img alt="Example of different padding value" src="../../../../content/images/2017/11/merge_padding.png">
</p>
<p>After this step, we have the last one: choosing the way of calculating transformation which will make landmarks from test images the most similar to reference points. Here we have 4 possible ways of doing it:</p>
<ul>
<li>Euclidean Transformation</li>
<li>Similarity Transformation</li>
<li>Affine Transformation</li>
<li>Projective Transformation</li>
</ul>
<p>The very good lecture about this transformation is from <a href="https://ags.cs.uni-kl.de/fileadmin/inf_ags/3dcv-ws11-12/3DCV_WS11-12_lec04.pdf">Augmented Vision Lab from University of Kaiserslautern</a>. Let's also quickly clarify it here.</p>
<h4 id="euclideantransformation">Euclidean Transformation</h4>
<p>It is rigid transformation which preserve distance between each pair of points. The Euclidean transformations include rotations and translations (3DoF).</p>
<h4 id="similaritytransformation">Similarity Transformation</h4>
<p>In contrast to Euclidean, this transformation also include scaling, so it can make images smaller/bigger (so does not preserve distances between points, 4Dof)</p>
<h4 id="affinetransformation">Affine Transformation</h4>
<p>Transformation which preserves points, straight lines and planes. Examples of affine transformations include translation, rotation, scaling, changing aspect ratio and shear mapping (6DoF).</p>
<h4 id="projectivetransformation">Projective Transformation</h4>
<p>It is the most advanced transformation, which in contrast to Affine does not preserve parallelism of lines. In contrast to other transformation, it create vanishing points and horizonts. As we look into transformation matrix we can notice that each parameter is independent (8DoF).</p>
<p align="center">
<img alt="Example of projection matrix and image transformation" src="../../../../content/images/2017/11/transformation.png" height="450" width="450">
</p>
<p>What is the visual difference between this transformation? Let's look into images. If we consider just MSE between reference points and projected points, the more degree of freedom we have then projection error is lower. In the other hand, the more degree of freedom we have, the more unnatural images look like. What is the more important, low MSE error or natural looking faces?</p>
<p align="center">
<img alt="Example of different image transformation" src="../../../../content/images/2017/11/compare_transform-1.png">
</p>    
<h3 id="3dalignment">3D Alignment</h3>
<p>So there are the steps for alignment of faces in 2D. 3D case in much less popular, but it was used one of the breakthourgh paper in Face Recognition, <a href="https://research.fb.com/publications/deepface-closing-the-gap-to-human-level-performance-in-face-verification/">Deep Face</a>. How the basic pipeline look here? In fact it depend on the algorithm because each of them have different pipeline. We are not the specialist at 3D Alignment as most of case it does not work better that 2D, most of time because of higher level of interpolation (like piecewise-affine transformation). Below images represent different approaches to 3D transformation.</p>
<p align="center">
<img alt="DeepFace approach to 3D Alignment" src="../../../../content/images/2017/11/deepface.png">
</p>
&amp;nbsp
<p align="center">
<img alt="Tal Hassner approach of 3D Alignment" src="../../../../content/images/2017/11/hasser.png">
</p>
<h2 id="experimentbasedon2dalignment">Experiment based on 2D Alignment</h2>
<p><strong>Note</strong>: Compared to earlier experiments, we would have different the <strong>Baseline</strong> model, exactly we will replace linear layer after last module with <a href="https://arxiv.org/abs/1406.4729">Spatial Pooling</a> (which is invariant to input size, always output the same size of features). We propose such idea because in next experiments we will have different input size (96x112 and 112x112). We could just increase the number of parameters in model but this could cause also increased overfitting then experiments would not be comparable. Worth noting that this model achieve slightly higher results at <code>LFW</code> but much lower at <code>BLUFR</code> protocol.</p>
<p>In first experiment we will compare multiple method of 2D alignment which differ with reference points and padding around the face. All method are open-source and used by Face-Recognition project which can be find at GitHub. Here are the tested methods:</p>
<ol>
<li>Basic: using MTCNN for points and <a href="https://github.com/wy1iu/sphereface/blob/master/preprocess/code/face_align_demo.m">SphereFace</a> reference points. Use Similarity transformation.</li>
<li>Crop: method taken from <a href="https://github.com/davidsandberg/facenet">Facenet</a> by David Sandberg, it just crop image with padding</li>
<li>Dlib: using <a href="http://blog.dlib.net/2017/02/high-quality-face-recognition-with-deep.html">dlib</a> method for Face-Aligment (get_face_chips) with 112 image size and 25% of padding (default value). This method use image-pyramid to make downsampling higher quality and 5 points (but different than SphereFace). Use Affine transformation.</li>
<li>OpenFace-3points:using original <a href="https://github.com/cmusatyalab/openface">OpenFace</a> method for Face Alignment, which use 3 point as a reference. Use Affine transformation.</li>
</ol>
<p align="center">
<img alt="Reference points of SphereFace, Dlib and OpenFace" src="../../../../content/images/2017/12/compare_ref_points-2.png">
</p>
<p align="center">
<img alt="Example images of each method" src="../../../../content/images/2017/11/compare_org-1.png">
</p>
<p align="center">
<img alt="Basic Face Alignment experiment" src="../../../../content/images/2017/12/119_basic_exp.png" height="155" width="1140">
</p> 
<p>Look like the SpherFace method is best (we think it is one of the reason of high performance of their algorithm). But surprisingly the second one is just raw face-crop without any alignment. It is pretty intriguing that is worth to mention that <a href="https://arxiv.org/abs/1503.03832">FaceNet</a> network from Google was also learn using raw images. Also recently there were several paper which claim that face-alignment is even harmful:</p>
<ol>
<li><a href="http://openaccess.thecvf.com/content_cvpr_2017_workshops/w6/papers/Ferrari_Investigating_Nuisance_Factors_CVPR_2017_paper.pdf">Investigating Nuisance Factors in Face Recognition with DCNN Representation</a></li>
<li><a href="https://arxiv.org/abs/1610.04823">To Frontalize or Not To Frontalize: A Study of Face Pre-Processing Techniques and Their Impact on Recognition</a></li>
</ol>
<p>We will look closer this statement, but compared to cited paper we will be comparing best Face-Alignment method vs Raw-Image.</p>
<p>Continuing the analysis of basic Face-Alignment method, we are not sure why <code>Dlib</code> method achieved so low results, maybe because of not including the upper part of head? The algorithm proposed in <code>OpenFace</code> is the weakest, it just contain to less details of face (as of the the creator of <code>OpenFace</code> code, we are really disappointed about that, in the other hand now we know what was one of the reason of poor performance).</p>
<p>As we analyse some basic method of Face-Alignment, now let's make more in-depth analysis of each component.</p>
<h2 id="whichkindofimagetransformationshouldwechoose">Which kind of Image Transformation should we choose?</h2>
<p>Let's make a quick experiment of comparing the image transformation. We will exclude the Euclidean transform as without scaling we should have scale invariant reference points and we don't. In this experiment we will be using baseline reference points (from <code>SphereFace</code> project).</p>
<p align="center">
<img alt="Image Transformation experiment" src="../../../../content/images/2017/12/117_image_trans.png" height="123" width="1138">
</p> 
<p align="center">
<img alt="Example of different image transformation" src="../../../../content/images/2017/11/compare_transform-1.png" height="300" width="300">
</p>  
<p>Look like that more natural images are better than fitting the reference points better. Even adding changing aspect ratio and shear make error slightly worse.</p>
<h2 id="doesnumberofreferencepointsmatters">Does number of reference points matters?</h2>
<p>As <code>OpenFace</code> provide 68 reference landmarks, we will use their software to make such test and check if more mean better. Also maybe some location of points are better than other. For testing is we choose following cases:</p>
<ul>
<li>3 points: eyes + nose</li>
<li>3 points: eyes + center of mouth</li>
<li>7 points: eyes + nose + 2 points from mouth</li>
<li>68 points: all points detected in face</li>
</ul>
<p>First two are defined at OpenFace. 7 points case was added as more complicated version, our imagination which points should be used (points are similar to references in SphereFace). The last case is just using all points. For each case we use Similarity Transformation.</p>
<p align="center">
<img alt="Face Align using different face points" src="../../../../content/images/2017/12/openface-points-1.png" height="400" width="400">
</p>  
<p align="center">
<img alt="Reference Points experiment" src="../../../../content/images/2017/12/123_points_matters.png" height="156" width="1138">
</p> 
<p>The results are not surprise for us, but maybe there are for you? So, look like 7 points and 68 points case works best, overall much better than basic setting for OpenFace. Why? Look like when choosing the reference points there should be suitable variety of points location, in the other hand the transformation would be not consistent/incorrect for many faces. Just look at results of <code>openface-3points-lip</code>, which point have not usual location. In such case the transformation in calculated using only small region of image, what could cause calculating transformation which we are not wanting too. It's also interesting that having 7 or 68 points create similar results, we supposed that 68 should be worse as face-edge points are not always visible what should cause undefined behaviour. But look like Similarity transform works nice with both cases. However, we would choose 7-points case which should generalize better. In summary, the number of reference points may be not as crucial, even 7 (or 5 like in our basic method) works nice. The most important thing is using points which extend over a large face area.</p>
<h2 id="howaccuracyoffacelandmarklocationaffectthemodel">How accuracy of face landmark location affect the model?</h2>
<p><code>MTCNN</code> algorithm was developed for Face-Detection and for Face-Landmark detection. As you may known, there also exist specialized method for just landmarks, which achieve higher accuracy. How does the more accurate landmark position affect final model? For this experiemnt we will use one of state-of-the-art models, <a href="https://github.com/MarekKowalski/DeepAlignmentNetwork">DeepAlignmentNetwork</a> created by <a href="http://home.elka.pw.edu.pl/~mkowals6/doku.php">Marek Kowalski</a>. The idea behind their algorithm is much more complicated than <code>MTCNN</code>.</p>
<p align="center">
<img alt="DeepAlignment algorithm" src="../../../../content/images/2017/12/kowalski.png" height="400" width="400">
</p>  
<blockquote>
<p>DAN is a multi-stage convolutional neural network for face alignment, where each stage analyzes the entire face image. This is facilitated thanks to the use of landmark heatmaps and feature images which transfers the information about the landmarks between stages. The use of an entire face image makes DAN very robust, which leads to state of the art accuracy on the most difficult datasets, including 72% reduction of failure rate on the 300W public test set.</p>
</blockquote>
<p>Also <code>DAN</code> detect 68 points and unfortunately they don't overlap with <code>MTCNN</code> points. To be able to use same reference points, we estimate the position of needed points (center of eyes, nose and center of month) using other detected points. The final points look good at pictures, but we must be aware of the possibility of a mistake already at the beginning of our experiment. Here are the results.</p>
<p align="center">
<img alt="Reference Points experiment" src="../../../../content/images/2017/12/124_kowalski.png" height="91" width="1138">
</p> 
<p>Look like the <code>DAN</code> algorithm does not influence of the final performance of model, the both result look really similar (and difference maybe not statistically significant, we could check it by doing several experiments, not once). Even our estimation of points does not hurt the performance. Maybe we don't need these points at all and using just raw image? Let's discuss it next.</p>
<h2 id="isreallyfacealignmentworthdoing">Is really Face-Alignment worth doing?</h2>
<p>As stated in <a href="http://openaccess.thecvf.com/content_cvpr_2017_workshops/w6/papers/Ferrari_Investigating_Nuisance_Factors_CVPR_2017_paper.pdf">Investigating Nuisance Factors in Face Recognition with DCNN Representation</a>, Face Recogniton may not need Face-Aligment at all. In this section I would like to repeat their experiments but using our network architecture and <code>LFW/BLUFR</code> for testing. The intuition tells us that this situation seems impossible. If it would, why so much effort would was put in to find a good method for Face-Alignment.<br>
Our test will be very similar to presented is paper and  basic alignment method would be presented by <code>SphereFace</code>. We will be testing different value of bounding-boxes around the face (parameterized by padding), like presented below. The size of input image from cropped faces is always 112x112. For aligned faces the longer side have value 112. Worth noting that mentioned paper used images 224x224.</p>
<p align="center">
<img alt="Cropping vs Face Alignment" src="../../../../content/images/2017/12/blog3-crop-pad.jpg" height="400" width="400">
</p>  
<p>Here are results from both experiments.</p>
<p align="center">
<img alt="Crop + Pad experiment" src="../../../../content/images/2017/12/121_crop_pad.png" height="189" width="1138">
</p> 
<p align="center">
<img alt="Face Alignment + Pad experiment" src="../../../../content/images/2017/12/120_mtcnn_pad.png" height="183" width="1138">
</p> 
<p>In contrast to cited paper, our experiments show the clear advantage of learning using faces after alignment in contrast to use raw faces. The different is &gt;5%, so we think that Alignment is it worth doing.<br>
Some paper like <a href="https://arxiv.org/abs/1503.03832">FaceNet</a> or <a href="http://www.robots.ox.ac.uk/~vgg/publications/2015/Parkhi15/parkhi15.pdf">VGGFaceNet</a> claim that when training with just cropped images, it is good idea to just align it for testing. But we are not sure how this image should look like as we do not have any reference points. We tried running <code>SphereFace</code> and <code>Dlib</code> alignment with different padding with no success. Our last try was just rotating the face so that eyes would be at one level without making any significant translation. However the results are not better than baseline. So we were not able to confirm that using aligned images for model learned on cropped faces boost the accuracy.<br>
However, for us this is kind of phenomena that cropping is working so well, but why? Our first intuition is that could be treated as Data Augmentation technique, because the faces are rotated relative to the center of the picture with different values. We will add <code>rotation</code> to our sets of Data Augmentation technique, which will be tested in next post.</p>
<p>We would like also discuss a additional phenomena: both 3 middle experiments  in their group achieve similar accuracy despite having different padding value. It just only show that network can distinguish between useful (foreground) and superfluous (background) information, what create some kind of attention, nice! Let's make the test by taking the feature map from one of convolutional module and visualize it. Our visualization will be not as nice as others because most of blogs/paper use last layer to show per class attention. We are just want to show the focus of entire  network before making any classification (so in fact where the features which describe the person come from). The displayed value is exactly mean absolute value. Let's hope they would look nice! Many test with different  configuration of padding will be taken. Enough talking, network, show what you have inside! (As you may notice, the more <code>pink</code> the color is, the higher value of features is)</p>
<p align="center">
<img alt="Visualization of Convolution layer: croped" src="../../../../content/images/2017/12/blog3_crop_Attention-1.png" height="600" width="600">
</p> 
<p align="center">
<img alt="Visualization of Convolution layer: aligned" src="../../../../content/images/2017/12/blog3_align_attention-1.png" height="600" width="600">
</p> 
<p>Above images look intriguing, don't they? Look like some of network have higher values in face-region, other not. Also network learned with aligned faces have overall more <code>pinky</code> images. But whether it adds anything to interpretation of network? Our answer is clear: besides it is nice, nothing special. As we are visualizing only just intermediate features, this state where network focus their attention. But you must be aware that this values are not normalized, so visualization show only peak values, in fact the attention map could be much bigger. Also why the <code>Attention Map</code> from some network with very high score doesn't look great? If you want to get better intuition about <code>visualizing the feature maps</code> we advice lecture from <a href="http://course.fast.ai/">fast.ai</a>  part 1: <a href="http://course.fast.ai/lessons/lesson7.html">7—EXOTIC CNN ARCHITECTURES; RNN FROM SCRATCH</a>.</p>
<h2 id="howaboutlettingthenetworktoaligntheimage">How about letting the network to align the image?</h2>
<p>As we let the network to learn which features are crucial for Face-Recognition, maybe we also let it to preprocess the images? Sound great, but how come? Just use <a href="https://arxiv.org/abs/1506.02025">Spatial Transformer Layer</a>! It enable to apply the image transformation based on features extracted from image, so no need for face landmarks.</p>
<p align="center">
<img alt="Spatial Transformer Layer" src="https://raw.githubusercontent.com/moodstocks/gtsrb.torch/master/resources/spatial-transformer-structure.png" height="600" width="600">
</p> 
<p>As presented at above images, it contain:</p>
<ol>
<li>Localication network: used for generating 6 parameters needed for image transformation</li>
<li>Grid generator: use provided 6 parameters to generate transformation grid</li>
<li>Sampler: used input image and grid output modified image</li>
</ol>
<p>If you would like to get more intuition about <code>STN</code>, read a introduction blog about it from <a href="https://kevinzakka.github.io/2017/01/10/stn-part1/">kevinzakk</a>, we really recommed it!.</p>
<p>This approach is not novel at Face-Recognition community, we know 3 papers already use this approach:</p>
<ol>
<li><a href="https://arxiv.org/abs/1605.07270">Learning a Metric Embedding for Face Recognition using the Multibatch Method</a></li>
<li><a href="https://arxiv.org/abs/1701.07174">Towards End-to-End Face Recognition through Alignment Learning</a></li>
<li><a href="https://arxiv.org/abs/1703.10818">End-To-End Face Detection and Recognition</a></li>
</ol>
<p>Each of mentioned paper use <code>STN</code> in different way. The first paper use similarity transform and pretrain the model using landmark annotationthen it is finetuned with recognition part. The second one want to compare different type of transformation (like we did earlier in the post) but using learnable <code>STN</code>. The last one use <code>STN</code> also face-detector.</p>
<p>Our approach would be the most similar to the paper <a href="https://arxiv.org/abs/1701.07174">Towards End-to-End Face Recognition through Alignment Learning</a> (despite using <a href="http://ydwen.github.io/papers/WenECCV16.pdf">CenterLoss</a>), but we will also try pretraining <code>STN</code> model.<br>
Out input data is cropped images with some of the paddding with final size <code>150x150</code>. The network architecture is 3 layer Convolutional with Pooling as a first component (which behave as a downsampler here). The input size to network is <code>112x96</code> (like in baseline experiment). This is all we need here, let's make experiments!</p>
<h4 id="pretrainedstn">Pretrained STN</h4>
<p>First experiments will just show if <code>STN</code> are able to learn transformation similar to our <code>baseline</code> and if we could easily boost accuracy by finetunning it.</p>
<p align="center">
<img alt="Pretrained STN experiment" src="../../../../content/images/2017/12/122_st_finetine.png" height="157" width="1138">
</p> 
<p>From all <code>pretraining</code> experiments the best results achieved method, where <code>STN</code> is pretrained  and then frozen during training connected with the <code>baseline FaceResNet</code> model. The results as against <code>baseline</code> are comparable beyond the <code>validation loss</code>  and <code>validation accuracy</code>, where STN model archive much higher values. In other cases when <code>STN</code> model is finetuned or even <code>FaceResNet</code> is learned from scratch, the results are much lower than the <code>baseline</code>. Concluding this part, it is not worth to use pretrained <code>STN</code> model in any configuration as final result in best case are same like the <code>baseline</code>.</p>
<h4 id="typesoftransformationinstn">Types of transformation in STN</h4>
<p align="center">
<img alt="STN transformation experiment" src="../../../../content/images/2017/12/125_st_tranforamation.png" height="122" width="1138">
</p> 
<p>These experiments were testing basic type of transformation which can be learned using <code>STN</code>. What are the results? The best method (<code>affine transformation</code>) does achieve similar performance like the best current method taken from <code>SpherFace</code> paper. We were really surprised by this results! This indicate that <code>STN</code> really can learn useful transformation. Let's also look at how this image transformation look like, how different they are compared to <code>baseline</code>.</p>
<p align="center">
<img alt="Transformation learned by Spatial Transformer Layer" src="../../../../content/images/2017/12/blog3-trans-stn.jpg" height="300" width="300">
</p> 
<p><code>STN</code> transformation are similar to each other and different from presented in <code>SphereFace</code> paper. This indicate that there are many ways of Face-Alignment to get high accuracy of model.</p>
<h4 id="morestnexperiments">More STN experiments</h4>
<p>Intrigued by high performance of <code>STN</code> we conduct some more experiments. We were adding more parameters  or <code>DropOut</code> to <code>Localization Network</code>. Also original <code>baseline FaceResNet</code> (without <code>AvgPool</code> model was tested).</p>
<p align="center">
<img alt="More STN experiment" src="../../../../content/images/2017/12/126_st_more_exp.png" height="360" width="1138">
</p> 
<p>It look like that adding more parameters to model make <code>STN</code> better in context of <code>Validation Loss</code>. However <code>LFW</code> and <code>BLUFR</code> are going in opposite direction because the results are getting worse. Also the original <code>baseline FaceResNet</code> model does not get any boost of performance in <code>LFW</code> and <code>BLUFR</code> despite having the competitive <code>Validation Loss</code>.</p>
<p>In summary, look like <code>STN</code> can provide very competitive results, especially with data distribution seen during training. Notwithstanding it is not clear why the same improvement is not seen at <code>LFW</code> and <code>BLUFR</code> benchmarks (for example models with same <code>Validation Loss</code> like <code>STN</code> model get much better results). Our intuition say that it may be caused by overfitting <code>STN</code> model to some <code>face distribution</code> then applying same transform for different distribution does not provide as huge boost. If this would be true, when more model regularization method should be used (<a href="https://arxiv.org/abs/1701.07174">Towards End-to-End Face Recognition through Alignment Learning</a> use <code>CenterLoss</code> as a additional regularization, maybe this is a clue for a better performance?). We will for sure get back to this method.</p>
<h2 id="3dfacealignment">3D Face Alignment</h2>
<p>In the last experiments we would like to conduct experiments with the most advanced technique for Face Alignment, 3D models. However, the <code>3D</code> pipeline is much more complicated with different training and testing methodology. Authors of most advanced method <a href="https://arxiv.org/abs/1708.07517">FacePoseNet: Making a Case for Landmark-Free Face Alignment</a>  were able to dispel our doubts about the pipeline the state-of-the-art method of 3D face modeling (see the comments). We need to read all the three paper carefully then maybe we will be able to create the <code>FacePoseNet</code> pipeline.</p>
<p>However, we run just experiments with different, much simpler method of 3D modeling, descibed in <a href="https://www.openu.ac.il/home/hassner/projects/frontalize/">Effective Face Frontalization in Unconstrained Images</a>. The results does not convince us to make any further efforts in this direction as many of images doesn't work well (especially with rotated faces).</p>
<p align="center">
<img alt="3D experiment" src="../../../../content/images/2017/12/118_3d.png" height="65" width="1138">
</p> 
<h2 id="conclusion">Conclusion</h2>
<p>It this post we have analysed a lot of ways of preparing <code>Face</code> image before using any Deep Learning model. Unfortunately none of method was able to detronize method proposed in <code>SphereFace</code>. Let's first answer our question asked at the beginning:</p>
<ol>
<li><strong>Which Face-Alignment method is best? Should we even care about it?</strong>
<ul>
<li>the best method is proposed by creators of <code>SphereFace</code> (<a href="https://github.com/wy1iu/sphereface/blob/master/preprocess/code/face_align_demo.m">code example</a>)</li>
</ul>
</li>
<li><strong>How many pad add around the face before feeding to image?</strong>
<ul>
<li>in case of <code>SphereFace</code> method, between 0 and 20</li>
</ul>
</li>
<li><strong>Which Image transform should we use?</strong>
<ul>
<li><code>Similarity Transformation</code> provide best results</li>
</ul>
</li>
<li><strong>Does quality of Facial Landmark really care?</strong>
<ul>
<li>when you have only use <code>5</code> of them, it does not significantly influence the final results</li>
</ul>
</li>
<li><strong>Does number and position of reference face landmark influence the accuracy?</strong>
<ul>
<li>choosing the both number and position of reference points is crucial for model accuracy</li>
</ul>
</li>
<li><strong>It is possible to learn a model for Face-Alignment?</strong>
<ul>
<li><code>STN</code> show that it is possible with results only worse that <code>SphereFace</code></li>
</ul>
</li>
</ol>
<p>There are also some extra positives sides of experiments as we can now give some recommendation for others researcher:</p>
<ol>
<li>When you are trying to create own <code>Face Alignment</code> algorithm always make sure that is surpass single image cropping (which is surprisingly hard baseline to beat).</li>
<li>The position of reference <code>Face Landmark</code> and amount of <code>padding</code> around the face is crucial for <code>Face Alignment</code> task.</li>
</ol>
<p>That is all in this post, we hope that there were interesting experiments for you. Next time we will test a <code>Data Augmentation</code> technique and their relation to <code>Face Recognition</code> task.</p>
<h2 id="references">References</h2>
<h3 id="papers">Papers</h3>
<ul>
<li><a href="https://arxiv.org/pdf/1704.08063.pdf">SphereFace : Deep Hypersphere Embedding for Face Recognition</a></li>
<li><a href="https://arxiv.org/abs/1604.02878">Joint Face Detection and Alignment using Multi-task Cascaded Convolutional Networks</a></li>
<li><a href="https://pdfs.semanticscholar.org/657a/58a220b1e69d14ef7a88be859d2f8d75e6a1.pdf">Menpo Benchmark</a></li>
<li><a href="https://research.fb.com/publications/deepface-closing-the-gap-to-human-level-performance-in-face-verification/">DeepFace: Closing the Gap to Human-Level Performance in Face Verification</a></li>
<li><a href="https://arxiv.org/abs/1503.03832">FaceNet</a></li>
<li><a href="https://arxiv.org/abs/1406.4729">Spatial Pooling</a></li>
<li><a href="http://openaccess.thecvf.com/content_cvpr_2017_workshops/w6/papers/Ferrari_Investigating_Nuisance_Factors_CVPR_2017_paper.pdf">Investigating Nuisance Factors in Face Recognition with DCNN Representation</a></li>
<li><a href="https://arxiv.org/abs/1610.04823">To Frontalize or Not To Frontalize: A Study of Face Pre-Processing Techniques and Their Impact on Recognition</a></li>
<li><a href="https://arxiv.org/abs/1706.01789">Deep Alignment Network: A convolutional neural network for robust face alignment</a></li>
<li><a href="http://www.robots.ox.ac.uk/~vgg/publications/2015/Parkhi15/parkhi15.pdf">Deep Face Recognition</a></li>
<li><a href="https://arxiv.org/abs/1506.02025">Spatial Transformer Layer</a></li>
<li><a href="https://arxiv.org/abs/1605.07270">Learning a Metric Embedding for Face Recognition using the Multibatch Method</a></li>
<li><a href="https://arxiv.org/abs/1701.07174">Towards End-to-End Face Recognition through Alignment Learning</a></li>
<li><a href="https://arxiv.org/abs/1703.10818">End-To-End Face Detection and Recognition</a></li>
<li><a href="https://arxiv.org/abs/1708.07517">FacePoseNet: Making a Case for Landmark-Free Face Alignment</a></li>
<li><a href="https://www.openu.ac.il/home/hassner/projects/frontalize/">Effective Face Frontalization in Unconstrained Images</a></li>
</ul>
<h3 id="projectsblogstutorials">Projects, blogs, tutorials</h3>
<ul>
<li><a href="https://github.com/davidsandberg/facenet">Facenet</a></li>
<li><a href="http://blog.dlib.net/2017/02/high-quality-face-recognition-with-deep.html">dlib</a></li>
<li><a href="https://github.com/cmusatyalab/openface">OpenFace</a></li>
<li><a href="http://course.fast.ai/">fast.ai</a></li>
<li><a href="https://kevinzakka.github.io/2017/01/10/stn-part1/">Deep Learning Paper Implementations: Spatial Transformer Networks - Part I</a></li>
<li><a href="https://ags.cs.uni-kl.de/fileadmin/inf_ags/3dcv-ws11-12/3DCV_WS11-12_lec04.pdf">Augmented Vision Lab from University of Kaiserslautern</a></li>
</ul>
</div>
                </section>

                <footer class="post-footer">
                    <section class="share">
                        <p>Share this post: <br>
                            <a class="share-icon icon-twitter" href="https://twitter.com/intent/tweet?text=Demystifying%20Face%20Recognition%20IV%3A%20Face-Alignment&amp;url=blcv.pl/static//2017/12/28/demystifying-face-recognition-iii-face-preprocessing/" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                                <i class="fa fa-twitter"></i>
                            </a>
                            <a class="share-icon icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=blcv.pl/static//2017/12/28/demystifying-face-recognition-iii-face-preprocessing/" onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
                                <i class="fa fa-facebook"></i>
                            </a>
                            <a class="share-icon icon-google-plus" href="https://plus.google.com/share?url=blcv.pl/static//2017/12/28/demystifying-face-recognition-iii-face-preprocessing/" onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
                                <i class="fa fa-google-plus"></i>
                            </a>
                            <a class="share-icon icon-reddit" href="https://www.reddit.com/submit?url=blcv.pl/static//2017/12/28/demystifying-face-recognition-iii-face-preprocessing/" onclick="window.open(this.href, 'reddit-share', 'width=850,height=530');return false;">
                                <i class="fa fa-reddit-alien"></i>
                            </a>
                        </p>
                    </section>

                </footer>

            </article>


            <aside class="read-next row">

                <div class="medium-6 columns text-left">
                    <a class="read-prev-story" href="../../../11/09/demystifying-face-recognition-iii-noise/">Demystifying Face Recognition III: Noise</a>
                    <a href="../../../11/09/demystifying-face-recognition-iii-noise/"><span class="arrow arrow-left"><i class="fa fa-chevron-left" aria-hidden="true"></i></span></a>
                </div>

             </aside>

            <h3>Comments:</h3>

            <div id="disqus_thread"></div>
            <script>
                var disqus_config = function () {
                    this.page.url = 'http://localhost:2368/2017/12/28/demystifying-face-recognition-iii-face-preprocessing/';  // Replace PAGE_URL with your page's canonical URL variable
                    this.page.identifier = '5a0fe47acf6e101744f5960a'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
                };

                (function() { // DON'T EDIT BELOW THIS LINE
                    var d = document, s = d.createElement('script');
                    s.async = true;
                    s.src = 'https://blcv-github-io.disqus.com/embed.js';
                    s.setAttribute('data-timestamp', +new Date());
                    (d.head || d.body).appendChild(s);
                })();
            </script>
            <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

        </main>

        <aside class="sidebar medium-4 large-3 columns show-for-medium">
            <div class="widget">
    <h4 class="widget-title">Featured Posts</h4>
    <div class="widget-content">
            <ul id="featured-posts" class="no-bullet">
        <li class="clearfix">
            <div class="clearfix">
                 <div class="featured-image">
                     <a href="index.html" class="thumbnail"><img src="../../../../content/images/2017/11/deepface_logo-1.png?w=80&amp;q=50"></a>
                 </div>
                <div class="featured-title">
                    <a href="index.html">Demystifying Face Recognition IV: Face-Alignment</a>

                    <div class="featured-meta">
                        <i class="fa fa-clock-o" aria-hidden="true"></i>
                        <time class="featured-time" datetime="2017-12-28">December 28 2017</time>
                    </div>
                </div>
            </div>
        </li>
        <li class="clearfix">
            <div class="clearfix">
                 <div class="featured-image">
                     <a href="../../../11/08/demystifying-face-recognition-ii-baseline/" class="thumbnail"><img src="../../../../content/images/2017/11/faceresnet.png?w=80&amp;q=50"></a>
                 </div>
                <div class="featured-title">
                    <a href="../../../11/08/demystifying-face-recognition-ii-baseline/">Demystifying Face Recognition II: Baseline</a>

                    <div class="featured-meta">
                        <i class="fa fa-clock-o" aria-hidden="true"></i>
                        <time class="featured-time" datetime="2017-11-08">November 08 2017</time>
                    </div>
                </div>
            </div>
        </li>
</ul>    </div>
</div>

<div class="widget">
    <h4 class="widget-title">Tags</h4>
    <div class="widget-content">
        <ul class="menu" id="tag-list">
                    <li><a class="tag" href="../../../../tag/face-recogition/">face-recogition</a></li>
        </ul>
    </div>
</div>

    <div class="widget">
        <h4 class="widget-title">Subscribe</h4>
        <div class="widget-content widget-subscribe">
            <p>Get the latest posts delivered right to your inbox.</p>
            <form method="post" action="http://localhost:2368/subscribe/" class="subscribe-form">
    <input class="confirm" type="hidden" name="confirm"><input class="location" type="hidden" name="location"><input class="referrer" type="hidden" name="referrer">

    <div class="">
        <input class="subscribe-email" type="email" name="email" placeholder="Your email address">
        <button class="button expanded subscribe-btn" type="submit">Subscribe</button>
    </div>
    <script type="text/javascript">(function(g,h,o,s,t){h[o]('.location')[s]=h[o]('.location')[s] || g.location.href;h[o]('.referrer')[s]=h[o]('.referrer')[s] || h.referrer;})(window,document,'querySelector','value');</script>
</form>


            <p>or subscribe <a href="http://cloud.feedly.com/#subscription/feed/blcv.pl/static//rss/"> <strong>via RSS</strong>
            </a> with Feedly!</p>
        </div>
    </div>
        </aside>
    </div>


            </div>

            <footer class="footer clearfix">
    <section class="copyright"><a href="../../../../">BLCV - Bartosz Ludwiczuk Computer Vision</a> © 2018</section>
    <section class="poweredby">Proudly published with <a href="https://ghost.org">Ghost</a></section>
</footer>        </div>

        
    </div>

    <div class="reveal" id="reveal-search">
    <div id="results"></div>
</div>
    <script src="../../../../assets/js/vendors.min.js?v=dbb78caff2"></script>
    <script src="../../../../assets/js/main.min.js?v=dbb78caff2"></script>

        <script src="../../../../assets/js/prism.min.js?v=dbb78caff2"></script>


    <script>
    window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
    ga('create', 'UA-108816291-2', 'auto');
    ga('send', 'pageview');
</script>
<script async src="https://www.google-analytics.com/analytics.js"></script>
</body>
